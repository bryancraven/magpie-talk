<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Performance Test Harness - Magpie Talk</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            max-width: 1200px;
            margin: 40px auto;
            padding: 20px;
            background: #f5f5f5;
        }
        h1 {
            color: #333;
        }
        .controls {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin-right: 10px;
        }
        button:hover {
            background: #0056b3;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .status {
            margin-top: 15px;
            font-weight: bold;
        }
        .results {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        th {
            background: #f8f9fa;
            font-weight: 600;
        }
        .summary {
            background: #e7f3ff;
            padding: 15px;
            border-radius: 4px;
            margin-top: 20px;
        }
        .summary h3 {
            margin-top: 0;
        }
        iframe {
            width: 100%;
            height: 600px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-top: 20px;
        }
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <h1>Performance Test Harness</h1>

    <div class="controls">
        <h2>Test Controls</h2>
        <label>
            Number of test runs:
            <input type="number" id="numRuns" value="10" min="1" max="50" style="width: 80px; padding: 5px;">
        </label>
        <br><br>
        <button id="startTest">Run Performance Tests</button>
        <button id="clearCache">Clear Cache & Test</button>
        <button id="exportData">Export Results (CSV)</button>
        <div class="status" id="status"></div>
    </div>

    <div class="results">
        <h2>Test Results</h2>
        <div id="summaryStats" class="summary hidden"></div>
        <table id="resultsTable" class="hidden">
            <thead>
                <tr>
                    <th>Run #</th>
                    <th>Page Load (ms)</th>
                    <th>API Fetch (ms)</th>
                    <th>Syllable Parsing (ms)</th>
                    <th>DOM Rendering (ms)</th>
                    <th>Total Time (ms)</th>
                    <th>Cached?</th>
                </tr>
            </thead>
            <tbody id="resultsBody"></tbody>
        </table>
    </div>

    <iframe id="testFrame" class="hidden" src="about:blank"></iframe>

    <script>
        const results = [];
        let currentRun = 0;
        let totalRuns = 0;
        let testStartTime = 0;

        const elements = {
            startTest: document.getElementById('startTest'),
            clearCache: document.getElementById('clearCache'),
            exportData: document.getElementById('exportData'),
            numRuns: document.getElementById('numRuns'),
            status: document.getElementById('status'),
            testFrame: document.getElementById('testFrame'),
            resultsTable: document.getElementById('resultsTable'),
            resultsBody: document.getElementById('resultsBody'),
            summaryStats: document.getElementById('summaryStats')
        };

        elements.startTest.addEventListener('click', () => runTests(false));
        elements.clearCache.addEventListener('click', () => runTests(true));
        elements.exportData.addEventListener('click', exportToCSV);

        async function runTests(clearCache) {
            results.length = 0;
            currentRun = 0;
            totalRuns = parseInt(elements.numRuns.value);
            elements.resultsBody.innerHTML = '';
            elements.resultsTable.classList.add('hidden');
            elements.summaryStats.classList.add('hidden');

            elements.startTest.disabled = true;
            elements.clearCache.disabled = true;

            if (clearCache) {
                elements.status.textContent = 'Clearing cache...';
                localStorage.clear();
                await new Promise(resolve => setTimeout(resolve, 500));
            }

            elements.status.textContent = `Running test 1/${totalRuns}...`;
            testStartTime = Date.now();
            runNextTest();
        }

        function runNextTest() {
            if (currentRun >= totalRuns) {
                finishTests();
                return;
            }

            currentRun++;
            elements.status.textContent = `Running test ${currentRun}/${totalRuns}...`;

            // Set up message listener for this test
            const messageHandler = (event) => {
                if (event.data && event.data.type === 'perfData') {
                    window.removeEventListener('message', messageHandler);
                    processTestResult(event.data.timings);
                }
            };
            window.addEventListener('message', messageHandler);

            // Load the page with a cache-busting parameter
            const url = `index.html?test=${currentRun}&_t=${Date.now()}`;
            elements.testFrame.src = url;
        }

        function processTestResult(timings) {
            results.push({
                run: currentRun,
                pageLoad: timings['Page Load → DOMContentLoaded'] || 0,
                apiFetch: timings['API: Featured Article Fetch'] || 0,
                parsing: timings['Syllable Parsing'] || 0,
                rendering: timings['DOM Rendering'] || 0,
                total: timings['Total: Load Featured Article'] || 0,
                cached: !timings['API: Featured Article Fetch'] || timings['API: Featured Article Fetch'] === 0
            });

            // Add row to table
            const row = document.createElement('tr');
            const result = results[results.length - 1];
            row.innerHTML = `
                <td>${result.run}</td>
                <td>${result.pageLoad.toFixed(2)}</td>
                <td>${result.apiFetch > 0 ? result.apiFetch.toFixed(2) : 'cached'}</td>
                <td>${result.parsing.toFixed(2)}</td>
                <td>${result.rendering.toFixed(2)}</td>
                <td><strong>${result.total.toFixed(2)}</strong></td>
                <td>${result.cached ? '✓' : '✗'}</td>
            `;
            elements.resultsBody.appendChild(row);
            elements.resultsTable.classList.remove('hidden');

            // Wait a bit before next test to avoid rate limiting
            setTimeout(runNextTest, 1000);
        }

        function finishTests() {
            const testDuration = Date.now() - testStartTime;
            elements.status.textContent = `All tests complete! (${(testDuration / 1000).toFixed(1)}s)`;
            elements.startTest.disabled = false;
            elements.clearCache.disabled = false;

            // Calculate statistics
            const stats = calculateStats();
            displayStats(stats);
        }

        function calculateStats() {
            const uncached = results.filter(r => !r.cached);
            const cached = results.filter(r => r.cached);

            const calcMetrics = (data) => {
                if (data.length === 0) return null;
                const sorted = [...data].sort((a, b) => a - b);
                return {
                    min: Math.min(...data),
                    max: Math.max(...data),
                    mean: data.reduce((a, b) => a + b, 0) / data.length,
                    median: sorted[Math.floor(data.length / 2)],
                    p95: sorted[Math.floor(data.length * 0.95)]
                };
            };

            return {
                all: {
                    total: calcMetrics(results.map(r => r.total)),
                    pageLoad: calcMetrics(results.map(r => r.pageLoad)),
                    parsing: calcMetrics(results.map(r => r.parsing)),
                    rendering: calcMetrics(results.map(r => r.rendering))
                },
                uncached: uncached.length > 0 ? {
                    total: calcMetrics(uncached.map(r => r.total)),
                    apiFetch: calcMetrics(uncached.map(r => r.apiFetch))
                } : null,
                cached: cached.length > 0 ? {
                    total: calcMetrics(cached.map(r => r.total))
                } : null,
                counts: {
                    total: results.length,
                    cached: cached.length,
                    uncached: uncached.length
                }
            };
        }

        function displayStats(stats) {
            const formatMetric = (metric) => {
                if (!metric) return 'N/A';
                return `
                    <strong>Mean:</strong> ${metric.mean.toFixed(2)}ms |
                    <strong>Median:</strong> ${metric.median.toFixed(2)}ms |
                    <strong>P95:</strong> ${metric.p95.toFixed(2)}ms |
                    <strong>Min:</strong> ${metric.min.toFixed(2)}ms |
                    <strong>Max:</strong> ${metric.max.toFixed(2)}ms
                `;
            };

            let html = `
                <h3>Summary Statistics (${stats.counts.total} runs)</h3>
                <p><strong>Cached runs:</strong> ${stats.counts.cached} | <strong>Uncached runs:</strong> ${stats.counts.uncached}</p>

                <h4>Total Time to Content:</h4>
                <p>${formatMetric(stats.all.total)}</p>

                <h4>Page Load → DOMContentLoaded:</h4>
                <p>${formatMetric(stats.all.pageLoad)}</p>

                <h4>Syllable Parsing:</h4>
                <p>${formatMetric(stats.all.parsing)}</p>

                <h4>DOM Rendering:</h4>
                <p>${formatMetric(stats.all.rendering)}</p>
            `;

            if (stats.uncached) {
                html += `
                    <h4>API Fetch (uncached only, ${stats.counts.uncached} runs):</h4>
                    <p>${formatMetric(stats.uncached.apiFetch)}</p>
                `;
            }

            if (stats.cached) {
                html += `
                    <h4>Total Time (cached only, ${stats.counts.cached} runs):</h4>
                    <p>${formatMetric(stats.cached.total)}</p>
                `;
            }

            elements.summaryStats.innerHTML = html;
            elements.summaryStats.classList.remove('hidden');
        }

        function exportToCSV() {
            if (results.length === 0) {
                alert('No results to export. Run tests first.');
                return;
            }

            const headers = ['Run', 'Page Load (ms)', 'API Fetch (ms)', 'Syllable Parsing (ms)', 'DOM Rendering (ms)', 'Total Time (ms)', 'Cached'];
            const rows = results.map(r => [
                r.run,
                r.pageLoad.toFixed(2),
                r.apiFetch.toFixed(2),
                r.parsing.toFixed(2),
                r.rendering.toFixed(2),
                r.total.toFixed(2),
                r.cached ? 'Yes' : 'No'
            ]);

            const csv = [
                headers.join(','),
                ...rows.map(row => row.join(','))
            ].join('\n');

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `magpie-talk-perf-${new Date().toISOString().split('T')[0]}.csv`;
            a.click();
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>
